---
title: "Why Is Concurrency Hard?"
description: "Why Is Concurrency Hard?"
date: 2024-07-18T05:00:00Z
image: "/images/posts/concurrency.png"
categories: ["go", "concurrency"]
authors: ["Hamza Masood"]
tags: ["go, concurrency"]
draft: false
---

Concurrency can be extrememly difficult to get right. Bugs can occur even after many iterations. Bugs can also occur after some change in timing from heavier disk utilization or more users logging in.

Running into concurrency issues is so common that we are now able to label common pitfalls. Below I have listed the most common issues of working with concurrency:

# Prerequisites
1. critical section
2. context

# Race Conditions
A race condition occurs when two or more processes must execute in a specific order, but the program allows for the operations to occur in any order, or an order that causes an error.
A classic example is one concurrent operation trying to read from a variable while (potentially) at the same time another concurrent operation is trying to write to it.
```go showLineNumbers
package main

import "fmt"

func main() {
	var data int
	go func() {
		data++
	}()
	if data == 0 {
		fmt.Println(data)
	}
}
```
one of 3 outcomes will occur:\
1. The go func at line 7 executes before the if statement at line 10 and 11 so nothing will be printed. This is what we would expect if the code was synchronous.
2. The if statement at line 10 and 11 executes before the go function at line 7 so 0 will be printed.
3. Perhaps the most unexpected case is that 1 will be printed. I would like for you to think how that would be possible.


<Accordion client:load title="Click here to see the reasoning for the 3rd outcome">
The output could be 1 because line 10 could run before line 8, and line 8 could run before line 11. In other words, the data variable increment executes after the check in the if statement but before the printing of the data variable.
</Accordion>

As you can see even a small snippet of code can lead to many outcomes. This is why every outcome must be thought of in order to not have a race conditions.

Thinking about a large passage of time between critical sections may help when reasoning about the different outcomes. For example, what would happen if an hour passed before the goroutine at line 7 could start? What would would happen if an hour passed after the check for the data variable at line 10?

Having a data race is quite hard to spot if you do not have all the outcomes noted down like above. This can be quite challenging in moderate to large size codebase. Another technique that may help for debugging would be to add sleep statements at different areas of the program. For example, a sleep statement could be added after line 7 before the data increment. This will most likely give enough time for the if statement to run before the data is incremented. But please remember:

<Notice type="warning">
Adding sleep statements is not a solution to the race condition!
</Notice>

We have simply made it increasingly unlikely for our program to product the "incorrect" output. All 3 scenarios could still potentially occur. The longer we sleep, the closer the program gets to logical correctness, but it will never be fully logically correct with the sleep statement. Adding sleep statements in your program will obviously decrease the performance as well.

Another technique that might help in detecting race conditions is testing your program in different environments. Data races normally tend to occur when there is a change in an environment that was not thought of like a variation in memory or CPU.

# Atomicity

If series of executions can in it's entirity without interruption in the defined context, then they are considered to be atomic.\
Atomic comes from the greek word Atom. Which means indivisible. Obviously, in modern physics we know this is not true. But it does bring the point across of a process or an execution being indivisible and uninterruptable.

It is important to think about the context of the running execution when we want to solve the problem of Atomicity. A process might be atomic in the context of the program but not in the context of the operating system. A process might be atomic in the context of the operating system but not in the context of the machine.

A very basic example would be incrememnting a variable:
```go showLineNumbers=false
i++
```

This operation may seem atomic but it abstracts a lot of the details for our convenience (and maybe our detriment). Here are all the operations that take place:

1. Read `i`
2. Increment `i`
3. Store `i`

Multiple steps are completed from a simple statement.Each step within the process is atomic but the process as a whole is not.

Most statements are not atomic. Thus proving another reason why concurrency can be very challenging.

# Memory Access Synchronization


